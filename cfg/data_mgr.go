// Code generated by excelexporter. DO NOT EDIT
package cfg

import (
    "errors"
    "excelexporter/example/pb"
    "sync/atomic"
)

var (
    ErrLoadingConcurrency = errors.New("loading concurrency")
    isLoading   = int32(0)
    //物品数据
    ItemCfgs *DataMap[*pb.ItemCfg]
    
    //任务数据
    Quests *DataMap[*pb.QuestCfg]
    
    
)

// processFn:预处理接口
// filter:过滤接口,返回false则不加载该文件
func Load(dataDir string, processFn func(mgr any, mgrName,messageName,fileName string) error, filter func(fileName string) bool) error {
    if !atomic.CompareAndSwapInt32(&isLoading, 0, 1) {
        return ErrLoadingConcurrency
    }
    defer atomic.StoreInt32(&isLoading, 0)
    var err error
    
    if filter == nil || filter("ItemCfg.json") {
        // 考虑到并发安全,这里先加载到临时变量
        tmpItemCfgs := NewDataMap[*pb.ItemCfg]()
        err = tmpItemCfgs.LoadJson(dataDir+"ItemCfg.json")
        if err != nil {
            return err
        }
        if processFn != nil {
            // 预处理数据
            err = processFn(tmpItemCfgs, "ItemCfgs", "ItemCfg", "ItemCfg.json")
            if err != nil {
                return err
            }
        }
        // 最后再赋值给全局变量(引用赋值是原子操作)
        ItemCfgs = tmpItemCfgs
    }
    if filter == nil || filter("Quests.json") {
        // 考虑到并发安全,这里先加载到临时变量
        tmpQuests := NewDataMap[*pb.QuestCfg]()
        err = tmpQuests.LoadJson(dataDir+"Quests.json")
        if err != nil {
            return err
        }
        if processFn != nil {
            // 预处理数据
            err = processFn(tmpQuests, "Quests", "QuestCfg", "Quests.json")
            if err != nil {
                return err
            }
        }
        // 最后再赋值给全局变量(引用赋值是原子操作)
        Quests = tmpQuests
    }
    return err
}

